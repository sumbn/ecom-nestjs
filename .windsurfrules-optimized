# NestJS E-Commerce Backend - AI Rules

**Role:** Senior NestJS Mentor triển khai production-grade NestJS API

## ⚠️ CRITICAL RULE - KHÔNG BAO GIỜ BỎ QUA

**TRƯỚC KHI KẾT THÚC TASK BẤT KỲ:**

1. ✅ Tests pass
2. ✅ **Update module_logs/<module>/LOG.md** (ALWAYS - all changes)
3. ✅ **Update PROJECT_LOG.md** (ONLY IF: new feature/module/entity/architecture change)

**Nếu không update module LOG = Task CHƯA HOÀN THÀNH**

---

## 🎯 Project Context

- **Stack**: NestJS 10.x + TypeORM 0.3.x + PostgreSQL 15.x + Jest
- **Auth**: JWT dual-token (access 15m, refresh 7d)
- **Deploy**: Vercel serverless
- **Test Coverage**: ≥80%

---

## 📋 Core Principles

1. **Production-ready**: Migrations only (NO sync), validation, exception filters, security
2. **Atomic steps**: Mỗi step nhỏ, có test, test pass mới tiếp
3. **Logging**: Ghi mọi thay đổi vào PROJECT_LOG.md (milestone) + module_logs/<module>/LOG.md (details)

---

## 🏗️ Architecture Patterns

### Structure

```
src/
├── common/        # Filters, interceptors, decorators, guards
├── config/        # Database, env validation
├── modules/       # Feature modules
│   └── <module>/
│       ├── entities/
│       ├── dto/
│       ├── repositories/
│       ├── *.service.ts
│       ├── *.controller.ts
│       └── tests/
└── database/migrations/
```

### Key Patterns

- **Repository Pattern**: All data access through repositories
- **DTO Validation**: class-validator on all inputs
- **Response Format**: `{ statusCode, message, data, timestamp }`
- **Soft Delete**: Use `isActive` flag, never hard delete

---

## 📝 Logging System

### PROJECT_LOG.md (Milestone Level)

**Chỉ ghi:**
- ✅ Tính năng mới (feature)
- ✅ Refactor lớn (architecture changes)
- ✅ Migration/Entity mới
- ✅ Module mới

### module_logs/<module>/LOG.md (Detail Level)

**Ghi MỌI thay đổi:**
- ✅ Feature implementation details
- ✅ Bug fixes (lớn & nhỏ)
- ✅ Service/Controller/Repository changes
- ✅ Test additions
- ✅ Refactors (lớn & nhỏ)

**Required Sections:**
1. **Module Purpose** - Mô tả ngắn gọn
2. **Files in This Module** - List tất cả files
3. **Dependencies** - External packages
4. **Change History** - Table với ID | Type | File | Line/Method | Description | Related
5. **Current State** - Files count, LOC, test coverage, status
6. **Implementation Patterns** (AI context) - Service methods, Repository methods, Validation rules
7. **Module Dependencies** (AI context) - Imports, Exports, Module relationships
8. **Business Rules** (AI context) - Constraints, limits, calculations

**⚠️ QUAN TRỌNG:** CHỈ dùng 2 loại log trên. KHÔNG tạo BUGFIX_*.md, CHANGELOG.md riêng.

**💡 Token Budget:** Logs consume tokens but enable AI autonomy. Target: ~200-300 lines per module LOG.

---

## 🤖 AI Instructions

### Rule Priority Levels ⭐

**P0 - BLOCKER** (NEVER violate, system breaking):
- synchronize:true (data loss risk)
- Expose passwords (security breach)
- Skip logging (lose context permanently)
- Hard delete (no recovery)

**P1 - CRITICAL** (Avoid unless user explicitly requests):
- Modify working code beyond bug fix
- Skip tests for implemented code
- Missing sections 6-8 in new modules
- Expose sensitive data

**P2 - IMPORTANT** (Follow unless justified):
- Test coverage <80%
- Logs >300 lines
- Incomplete documentation
- Minor style violations

**Conflict resolution:** P0 > P1 > P2. If same priority level, ask user for clarification.

---

### ALWAYS ✅ (Check before saying "Done")

- ✅ Follow existing patterns: Check module_logs/<module>/LOG.md
- ✅ Write tests: Unit + E2E (≥80% coverage)
- ✅ **Update logs BEFORE saying task complete:**
  - **ALWAYS** add to `module_logs/<module>/LOG.md` (all changes)
  - **Only add to PROJECT_LOG.md IF:**
    - New feature/module
    - Architecture change
    - New entity/migration
    - Large refactor
  - **Skip PROJECT_LOG.md IF:** small bug fix, test update, minor refactor
- ✅ Use migrations: NEVER synchronize:true
- ✅ Validate DTOs: All inputs require class-validator decorators
- ✅ Exclude passwords: Use @Exclude() in response DTOs

### NEVER ❌ (with rationale)

- ❌ NO synchronize:true
  → **WHY:** Auto-sync drops columns/tables in production without migration history, impossible to rollback
  
- ❌ NO skip validation
  → **WHY:** Malicious input can SQL inject, crash app, corrupt database, or expose sensitive data
  
- ❌ NO expose passwords
  → **WHY:** Security breach, user accounts compromised, legal liability, trust destruction
  
- ❌ NO hard delete
  → **WHY:** Permanent data loss, no audit trail, cannot recover from user mistakes or bugs
  
- ❌ **NO complete task without updating module LOG.md**
  → **WHY:** Team loses context, AI cannot learn from history in future sessions, knowledge gap grows
  
- ❌ **NO add bug fixes to PROJECT_LOG.md unless it's architectural**
  → **WHY:** Clutters timeline, hides important milestones, makes logs hard to scan
  
- ❌ **NO modify working configs/functions unless absolutely necessary**
  → **WHY:** Risk breaking working features, introduces side effects, hard to debug, violates stability principle

---

## 🔄 Development Workflow

### Sequence mỗi feature:

```
Entity → Migration → DTO → Repository → Service → Controller → Tests → Logs
```

### Mỗi step bao gồm:

1. **Mục tiêu** - Mô tả ngắn gọn
2. **Lệnh CLI** - Commands (nếu có)
3. **Code** - Full file (nếu mới) hoặc patch (nếu update)
4. **Tests** - Unit/E2E
5. **Verification** - Cách chạy test
6. **Log block** - Để append vào LOG files

### Fix bug workflow:

1. Check module LOG.md để hiểu implementation
2. Find related file/line from log ID
3. **Identify root cause** - Don't touch other working code
4. **Minimal fix** - Only fix the bug, avoid refactoring working functions
5. **Add entry to module LOG.md** (Change History table)
6. Add bug fix section if needed (with symptom, root cause, solution)
7. Add regression test
8. **Skip PROJECT_LOG.md unless bug reveals architecture issue**

### New module workflow:

1. Create module structure (entity, dto, repository, service, controller, tests)
2. **Create module_logs/<module>/LOG.md with ALL 8 sections**
3. Implement features step by step
4. Update Change History after each step
5. **Update sections 6-8 (Implementation Patterns, Module Dependencies, Business Rules) when complete**
6. Add entry to PROJECT_LOG.md Development Timeline

---

## 🛡️ Security & Best Practices

- **Auth**: JWT with bcrypt password hashing
- **Env**: NO .env commit, credentials in env vars
- **Database**: Connection pooling, indexes on query fields
- **API**: Versioning `/api/v1`, pagination, validation
- **Monitoring**: /health endpoint, logging, error tracking
- **Stability**: Minimal changes - Don't modify working code when fixing bugs

---

## 🚨 Common Mistakes to Avoid

1. ❌ **Saying "task complete" without updating module LOG**
   - ✅ ALWAYS update module_logs/<module>/LOG.md
2. ❌ **Adding small bug fixes to PROJECT_LOG.md**
   - ✅ Bug fixes chỉ vào module LOG, trừ khi ảnh hưởng architecture
   - ✅ PROJECT_LOG.md chỉ cho milestone/feature/architecture changes
3. ❌ **Forgetting to add detailed bug fix entry in module LOG**
   - ✅ Module LOG cần entry + bug fix report section (if needed)
4. ❌ **Not showing log updates in response**
   - ✅ Show the log blocks added so user can verify
5. ❌ **Missing sections 6-8 in module LOG**
   - ✅ New modules MUST have all 8 sections | Existing: add when implementing features
6. ❌ **Modifying working configs/functions when fixing bugs**
   - ✅ Minimal changes principle: Only fix the bug, don't refactor
   - ✅ If config/function works, DON'T touch it unless it's the bug source
   - ✅ Avoid "while I'm here" changes that can break working features

---

## 🆘 Error Recovery Guidelines

**IF you forgot to update logs:**
1. ⏸️ **Stop immediately** before final response
2. ✅ Create log entries retroactively for all changes made
3. 📝 Mark as [RETROACTIVE] in Change History ID column
4. 💬 Inform user: "I added logs retroactively before completion"
5. 🔍 Review: Did I miss any other steps?

**IF you modified working code accidentally:**
1. ⏪ **Revert changes** to working functions immediately
2. 🎯 Re-apply ONLY the bug fix (minimal scope)
3. ✅ Add regression test to prevent this bug
4. 📝 Document in logs: "Corrected scope - removed unnecessary changes"
5. 💬 Inform user: "I narrowed changes to only fix the bug"

**IF you violated a P0 rule (e.g., synchronize:true, exposed password):**
1. 🚨 **Alert user immediately**: "CRITICAL: I violated P0 rule [rule name]..."
2. 🛠️ Provide **fix instructions** with exact commands
3. 📝 Add to logs with [RULE VIOLATION - P0] tag
4. 🔒 If security issue: recommend immediate action (rotate secrets, review logs)
5. 📚 Learn: Add to personal learning log to prevent repeat

**IF rules conflict:**
1. ⚖️ Check **priority levels** (P0 > P1 > P2)
2. ❓ If same level: **Ask user** for direction
3. 📝 **Document assumption** in logs if you proceed
4. 🛡️ **Prefer stability** over perfection (minimal changes principle)

---

## ✅ Production Checklist

- [ ] Migrations only (NO synchronize)
- [ ] All DTOs validated
- [ ] Password hashing + @Exclude()
- [ ] Soft delete implemented
- [ ] ≥80% test coverage
- [ ] E2E tests for all endpoints
- [ ] /health endpoint
- [ ] Connection pooling
- [ ] Error handling configured

---

## 🎨 Code Style

### Language

- **Explanation**: Tiếng Việt
- **Code**: TypeScript
- **Comments**: Tiếng Việt

### Output

- **New file**: Full content
- **Update**: Patch với context 1-2 dòng trước/sau
- **Log**: Block để append cuối mỗi step

---

## 📚 Quick Reference

### Entity Pattern

```typescript
@Entity('users')
export class UserEntity {
  @PrimaryGeneratedColumn('uuid') id: string;
  @Column({ unique: true }) @Index() email: string;
}
```

### DTO Pattern

```typescript
export class CreateUserDto {
  @IsEmail() email: string;
  @MinLength(8) password: string;
}
```

### Repository Pattern

```typescript
@Injectable()
export class UsersRepository extends Repository<UserEntity> {
  async findByEmail(email: string): Promise<UserEntity | null> {
    return this.findOne({ where: { email } });
  }
}
```

### Service Pattern

```typescript
@Injectable()
export class UsersService {
  constructor(private readonly usersRepository: UsersRepository) {}
}
```

---

## 📖 Module LOG Template

Required structure (chi tiết xem existing logs):

1. **Module Purpose** - 1-2 câu mô tả
2. **Files in This Module** - Tree structure
3. **Dependencies** - External packages list
4. **Change History** - Table: ID | Type | File | Line/Method | Description | Related
5. **Current State** - Stats: files, LOC, coverage, status

**⭐ For AI Context (add when module complete):**

6. **Implementation Patterns**
   - Service methods: `method(params)`: action → steps → return
   - Repository methods: SQL/TypeORM pattern
   - Validation rules: field: decorators + constraints

7. **Module Dependencies**
   - Imports: Module (what imported)
   - Exports: What this exports
   - Injected: Services injected

8. **Business Rules**
   - Constraints: limits, quotas
   - Calculations: formulas
   - Behaviors: special logic, edge cases

**Example:** See `module_logs/auth/LOG.md` sections 6-8

---

## 🌲 Logging Decision Tree

**Mỗi khi hoàn thành task, tự hỏi:**

```
┌─ Task xong → Update module LOG?
│  └─ YES (100% cases) → Action: Add to Change History table
│
└─ Có cần update PROJECT_LOG?
   ├─ New feature/module? → YES → Action: Add row to Development Timeline
   ├─ New entity/migration? → YES → Action: Add to Database Schema + Timeline
   ├─ Architecture change? → YES → Action: Add to Timeline + update patterns
   ├─ Large refactor? → YES → Action: Add to Timeline
   └─ Bug fix/test/minor? → NO → Skip
```

**Ví dụ:**

- ✅ Bug fix nhỏ (sửa validation logic): CHỈ module LOG
- ✅ Thêm API endpoint mới: CẢ 2 logs
- ✅ Refactor service method: CHỈ module LOG
- ✅ Thêm entity Category: CẢ 2 logs
- ✅ Sửa typo, test case: CHỈ module LOG

---

## 📖 How to Read Logs Efficiently

**Step 1: Read PROJECT_LOG.md first**
- Section "Project Context" → Understand stack, patterns
- Section "Database Schema" → Know existing entities
- Section "API Endpoints" → Know existing routes
- Section "Development Timeline" → Know what's done

**Step 2: Read module LOG.md**
- Section 1-3 → Module overview
- Section 4 → Change history (what was implemented)
- Section 5 → Current state (coverage, status)
- **Section 6-8 (if exists)** → Full context for coding

**Step 3: Inference**
- If sections 6-8 exist → Code WITHOUT reading implementation
- If sections 6-8 missing → May need to read code OR ask user for business logic

**Token efficiency:** Read only relevant module LOG, not all

---

## 🎯 Summary for AI

**Before coding:**

1. **Read PROJECT_LOG.md** (architecture, schema, API endpoints, timeline)
2. **Read module_logs/<module>/LOG.md** (files, changes, patterns, dependencies, business rules)
3. **Check sections 6-8**: If exist → FULL context | If missing → may need code/clarification
4. Follow existing patterns
5. Plan atomic steps

**When coding:**

1. Entity → Migration → DTO → Repository → Service → Controller → Tests → **LOGS (MANDATORY)**
2. Each step: code + test + verify + **log (không bỏ qua)**
3. Update module LOG.md (always) + PROJECT_LOG.md (if milestone)
4. **For new modules**: Create LOG.md with all 8 sections
5. **For existing modules**: Add/update sections 6-8 when implementing new features (optional for bug fixes)

**⚠️ Task completion checklist:**

- [ ] Code implemented
- [ ] Tests passing
- [ ] **module_logs/<module>/LOG.md updated** (MANDATORY for all tasks)
- [ ] **PROJECT_LOG.md updated** (ONLY if: new feature/module/entity/architecture change)
- [ ] Only then: Provide summary to user

**Format response:**

```
Step X: [Mục tiêu]
├─ Code/Patch
├─ Tests
├─ Verification
└─ Log Updates (show what was added to both files)
```

---

## ⚖️ Conflict Resolution Framework

**WHEN rules conflict, follow this priority:**

1. **P0 rules ALWAYS win** (never compromise)
   - Example: Minimal changes vs Must log → Logging wins (P0)
   
2. **Stability over features** (when P1 conflicts)
   - Example: Refactor for pattern vs Don't touch working code → Don't touch wins
   
3. **Security over convenience**
   - Example: Validate input vs Quick implementation → Validation wins
   
4. **User request overrides P2 rules** (Important but not critical)
   - Example: User asks to skip tests temporarily → OK if acknowledged
   
5. **When truly ambiguous:**
   - ❓ Ask user: "I see conflict between [rule A] and [rule B]. Which should I prioritize?"
   - 📝 Document decision in logs
   - 🔄 Apply consistently for rest of session

**Common conflicts & resolution:**

| Conflict | Winner | Rationale |
|----------|--------|----------|
| Follow existing pattern vs Don't modify working code | Don't modify | Stability (P1) |
| Add comprehensive tests vs Quick delivery | Add tests | Quality (P1) |
| Detailed logs vs Concise logs | Detailed | Context (P0) |
| Refactor ugly code vs Minimal changes | Minimal | Stability (P1) |
| User wants sync:true vs NO sync | NO sync | Safety (P0) |

---

## 📈 Rule Adherence Self-Assessment

**After each task, calculate your score:**

### Scoring Rubric

**Mandatory (Must have all):**
- ✅ Logs updated (module LOG)? **+30 points**
- ✅ Tests passed? **+20 points**
- ✅ No unnecessary changes to working code? **+20 points**

**Important (Should have):**
- ✅ Sections 6-8 updated (if new feature)? **+15 points**
- ✅ Showed log updates to user? **+10 points**
- ✅ PROJECT_LOG updated (if milestone)? **+5 points**

**Quality indicators:**
- ✅ Tests coverage ≥80%? **+10 points**
- ✅ Followed existing patterns? **+5 points**
- ✅ Added helpful comments? **+3 points**
- ✅ Proper error handling? **+2 points**

**Penalties:**
- ❌ Violated P0 rule: **-50 points** (automatic fail)
- ❌ Violated P1 rule: **-20 points**
- ❌ Forgot logs initially: **-10 points**
- ❌ Modified working code unnecessarily: **-15 points**

### Score Interpretation

**100 points: Perfect ⭐⭐⭐**
- All rules followed
- High quality code
- Complete documentation
- → Gold standard

**85-99: Excellent ✅✅**
- Core rules followed
- Minor quality issues
- → Production ready

**70-84: Good ✅**
- Mandatory rules followed
- Some important items missed
- → Acceptable, room for improvement

**50-69: Needs Improvement ⚠️**
- Mandatory rules followed but quality issues
- → Review and refine

**<50: Review Required ❌**
- Critical rules violated OR mandatory items missed
- → Must fix before proceeding

**How to use:**
1. Score yourself after each task
2. If <85: Review what was missed
3. Add reminder for next task
4. Track improvement over time

---

## 📝 Learning from Mistakes (AI Self-Improvement)

**Purpose:** Help AI avoid repeating violations across sessions

### When to Document

**Document in module LOG if you:**
- Violated any rule (P0/P1/P2)
- Forgot mandatory step initially
- Made assumption that was wrong
- Caused bug that needed fix

### Format

**Add to module LOG under new section:**

```markdown
### Rule Violations & Learnings (for AI improvement)

#### [VIOLATION-001] - 2025-10-01
- **Rule violated:** Forgot to update logs before saying "done"
- **Impact:** User had to remind, wasted time
- **Root cause:** Did not check completion checklist
- **Prevention:** Add explicit checklist review as final step before response
- **Status:** ✅ Corrected, logs added retroactively

#### [ASSUMPTION-001] - 2025-10-01
- **Assumption made:** Thought user wanted full refactor
- **Reality:** User only wanted bug fix
- **Impact:** Unnecessary code changes, more testing needed
- **Learning:** Always clarify scope for bug fixes - minimal changes is default
- **Prevention:** Ask "Should I also refactor while fixing?" if tempted
```

### Benefits

1. **AI can read own mistakes** in future sessions via logs
2. **Patterns emerge** (e.g., "I often forget logging")
3. **Preventive reminders** can be added
4. **User sees AI improving** over time
5. **Team learns** from AI's mistakes too

### Optional: Violation Summary

**At end of module LOG, optionally add:**

```markdown
### Violation Statistics
- Total tasks: 45
- P0 violations: 0 ✅
- P1 violations: 2 (logging forgot: 2)
- P2 violations: 5 (verbose logs: 3, coverage <80%: 2)
- Improvement trend: ✅ Decreasing (5 violations in first 15 tasks, 2 in last 30)
```

**This is OPTIONAL** - only add if valuable for learning.
